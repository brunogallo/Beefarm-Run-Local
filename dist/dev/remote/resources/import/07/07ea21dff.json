[1,["cdf0a53c-3cd6-4e60-93cb-74eb297a689a@f9941","2ebf76d1-5c7e-4b4d-82b0-b2ef7d9d50e2@f9941","07029773-76ce-4bd5-bf4f-089456851093@6c48a","5c84e09d-37b5-4f22-92b6-062e463b94aa@f9941","b42e9ee8-da3f-4056-9b1e-d3e62cd49409","b7de8669-ea24-4172-8d5c-4143bc61a393@f9941","29a6880d-499d-4dbc-baa3-7578bcea021c@f9941","157ea9d8-d71d-434d-af72-95277b70cc52@f9941","4e647951-bb9a-47e8-994f-44a91e6bf692@f9941","dc1061de-79c9-4ee5-984d-439f77f41051@f9941","07029773-76ce-4bd5-bf4f-089456851093@f9941","a4ed2150-ee12-4362-8440-64f7261d9b1d@f9941","fd2a59a0-3c30-4042-a290-dd16c1ac72fe@f9941","ae11fe6f-735d-48ec-8392-6525d61252fd@f9941","e5cc5575-0d42-4de1-9276-037a84e46b8b","624281b9-19e2-4763-b3bb-f9514df136db","30547468-f034-48b0-b03e-e49b4640c56f","8e0b32c3-2bb0-482b-8eff-4c1cfdf6781a","e248fd04-6a81-4e74-a94b-381e55111b21@116ec","9abc2465-bc0e-4161-ad0d-9eae3f99874d@f9941","c532ad1e-2a91-4647-a6cd-a6355ac96e92@f9941","157ea9d8-d71d-434d-af72-95277b70cc52@6c48a","29a6880d-499d-4dbc-baa3-7578bcea021c@6c48a","2ebf76d1-5c7e-4b4d-82b0-b2ef7d9d50e2@6c48a","056979ad-f70a-4584-9364-1a3c51894941","4e647951-bb9a-47e8-994f-44a91e6bf692@6c48a","66145609-8eef-4a37-a57a-5f295f2e8118","994de4d2-4c53-4e51-ae8e-6183edfa9f6f","9abc2465-bc0e-4161-ad0d-9eae3f99874d@6c48a","a4ed2150-ee12-4362-8440-64f7261d9b1d@6c48a","ae11fe6f-735d-48ec-8392-6525d61252fd@6c48a","cdf0a53c-3cd6-4e60-93cb-74eb297a689a@6c48a","dc1061de-79c9-4ee5-984d-439f77f41051@6c48a","705f7a9e-0cc9-47e1-9cb1-ba097084dfda@6c48a","29b3dc55-d6e9-410e-8d92-e6b77eb3297b","fd2a59a0-3c30-4042-a290-dd16c1ac72fe@6c48a"],["node","_textureSource","_spriteFrame","_effectAsset","root","chuizi","plantEffNode","fruitNode","Headeffect","effect","lock","Select","land","damageNode","damage","data","_font"],["cc.SpriteFrame",["cc.Node",["_name","_layer","_components","_prefab","_parent","_children","_lpos"],1,9,4,1,2,5],["cc.Node",["_name","_layer","_active","_parent","_components","_prefab","_lpos"],0,1,12,4,5],["cc.UITransform",["node","__prefab","_contentSize","_anchorPoint"],3,1,4,5,5],["cc.Sprite",["_sizeMode","node","__prefab","_spriteFrame"],2,1,4,6],["cc.PrefabInfo",["fileId","targetOverrides","root","asset"],1,1,1],["cc.EffectAsset",["_name","shaders","techniques"],0],["cc.Prefab",["_name"],2],["cc.CompPrefabInfo",["fileId"],2],["2fe55IH1ZVM0rtWR5LxaCTD",["node","__prefab","landIcon","damage","damageNode","land","Select","lock","effect","Headeffect","fruitNode","plant","plantEffNode","exception","matEff","chuizi"],3,1,4,3,1,1,1,1,1,1,1,1,2,1,3,3,1],["cc.PolygonCollider2D",["node","__prefab","_points"],3,1,4,12],["cc.PrefabInfo",["root","fileId","asset"],1,1],["cc.Button",["_transition","node","__prefab","clickEvents"],2,1,4,9],["cc.ClickEvent",["_componentId","handler","target"],1,1],["1afc6GKgYZDSIGFzuTJTdVl",["node","__prefab"],3,1,4],["cc.UIOpacity",["node","__prefab"],3,1,4],["cc.Label",["_string","_actualFontSize","_isSystemFontUsed","_cacheMode","node","__prefab","_color","_font"],-1,1,4,5,6],["cc.LabelOutline",["node","__prefab","_color"],3,1,4,5],["cc.Material",["_states","_defines","_props"],1,12],["cc.Material",["_props","_states","_defines"],0]],[[8,0,2],[11,0,1,2,3],[3,0,1,2,1],[1,0,1,4,2,3,6,3],[2,0,1,3,4,5,6,3],[3,0,1,1],[3,0,1,2,3,1],[5,0,2,3,2],[4,1,2,3,1],[4,1,2,1],[6,0,1,2,4],[14,0,1,1],[1,0,1,4,5,2,3,3],[1,0,1,4,5,2,3,6,3],[4,0,1,2,2],[19,0,1,2,4],[1,0,1,4,2,3,3],[15,0,1,1],[7,0,2],[1,0,1,5,2,3,3],[2,0,1,3,4,5,3],[2,0,2,1,3,4,5,6,4],[9,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,1],[10,0,1,2,1],[5,0,1,2,3,3],[12,0,1,2,3,2],[13,0,1,2,3],[16,0,1,2,3,4,5,6,7,5],[17,0,1,2,1],[18,0,1,2,3]],[[[[10,"../shader/Shine",[{"hash":928232392,"name":"../shader/Shine|s-vs:vert|s-fs:frag","blocks":[{"name":"ALPHA_TEST_DATA","stageFlags":16,"binding":0,"members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"]},{"name":"RATE","stageFlags":16,"binding":1,"members":[{"name":"shineColor","type":16,"count":1},{"name":"shineSaturation","type":13,"count":1},{"name":"shineContrast","type":13,"count":1},{"name":"shineRotation","type":13,"count":1},{"name":"timeScale","type":13,"count":1},{"name":"shineSpeed","type":13,"count":1},{"name":"shineScale","type":13,"count":1},{"name":"shineWidth","type":13,"count":1},{"name":"shineSmoothness","type":13,"count":1},{"name":"shineFade","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"shineShaderMask","type":28,"count":1,"stageFlags":16,"binding":2,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":21,"location":1,"defines":[]},{"name":"a_color","format":44,"location":2,"defines":[]}],"varyings":[{"name":"color","type":16,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"uv0","type":14,"count":1,"stageFlags":17,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if USE_LOCAL\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n  };\n#endif\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec2 a_texCoord;\nlayout(location = 2) in vec4 a_color;\nlayout(location = 0) out vec4 color;\nlayout(location = 1) out vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matWorld * pos;\n  #endif\n  #if USE_PIXEL_ALIGNMENT\n    pos = cc_matView * pos;\n    pos.xyz = floor(pos.xyz);\n    pos = cc_matProj * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#if USE_ALPHA_TEST\n  layout(set = 1, binding = 0) uniform ALPHA_TEST_DATA {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n    if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n    if (alpha < alphaThreshold) discard;\n  #endif\n}\nlayout(location = 0) in vec4 color;\nlayout(location = 1) in vec2 uv0;\nlayout(set = 2, binding = 11) uniform sampler2D cc_spriteTexture;\nlayout(set = 1, binding = 2) uniform sampler2D shineShaderMask;\nlayout(set = 1, binding = 1) uniform RATE{\n  vec4 shineColor;\n  float shineSaturation;\n  float shineContrast;\n  float shineRotation;\n  float timeScale;\n  float shineSpeed;\n  float shineScale;\n  float shineWidth;\n  float shineSmoothness;\n  float shineFade;\n};\nvec3 RotateAroundAxis( vec3 center, vec3 original, vec3 u, float angle )\n{\n  original -= center;\n  float C = cos( angle );\n  float S = sin( angle );\n  float t = 1.0 - C;\n  float m00 = t * u.x * u.x + C;\n  float m01 = t * u.x * u.y - S * u.z;\n  float m02 = t * u.x * u.z + S * u.y;\n  float m10 = t * u.x * u.y + S * u.z;\n  float m11 = t * u.y * u.y + C;\n  float m12 = t * u.y * u.z - S * u.x;\n  float m20 = t * u.x * u.z - S * u.y;\n  float m21 = t * u.y * u.z + S * u.x;\n  float m22 = t * u.z * u.z + C;\n  mat3 finalMatrix = mat3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );\n  return finalMatrix*original + center;\n}\nvec4 frag () {\n  vec4 source = texture( cc_spriteTexture, uv0 );\n  vec3 mean = vec3(( source.x + source.y + source.z ) / 3.0 );\n  vec3 m1 = mix( mean , source.rgb , shineSaturation);\n  vec3 m2 = max( m1 , 0.0001 );\n  vec3 contrast = vec3(max( shineContrast , 0.001 ));\n  float tscale =cc_time.x * timeScale;\n  vec2 uvoffset = uv0;\n  vec3 sinspace = RotateAroundAxis( vec3( 0,0,0 ), vec3( ( ( tscale * shineSpeed ) + ( shineScale * uvoffset ) ) ,  0.0 ), vec3( 0,0,1 ), ( ( shineRotation / 360.0 ) * PI ) );\n  float sinWidth = ( shineWidth + -1.0 );\n  float a1 = clamp( ( ( ( sin( ( ( sinspace.x + sinspace.y ) * 10.0 ) ) + sinWidth ) * ( 2.0 - sinWidth ) ) * shineSmoothness ) , 0.0 , 1.0 );\n  vec4 mask = texture( shineShaderMask, uv0 );\n  vec4 c = vec4(( source.rgb + ( ( pow( m2 , contrast ) * (shineColor).rgb ) * a1 * ( shineFade * ( mask.r * mask.a ) ) ) ) , (source).a)*color;\n  c.rgb *= c.a;\n  ALPHA_TEST(c);\n  return c;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if USE_LOCAL\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n  };\n#endif\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nout vec4 color;\nout vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matWorld * pos;\n  #endif\n  #if USE_PIXEL_ALIGNMENT\n    pos = cc_matView * pos;\n    pos.xyz = floor(pos.xyz);\n    pos = cc_matProj * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#if USE_ALPHA_TEST\n  layout(std140) uniform ALPHA_TEST_DATA {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n    if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n    if (alpha < alphaThreshold) discard;\n  #endif\n}\nin vec4 color;\nin vec2 uv0;\nuniform sampler2D cc_spriteTexture;\nuniform sampler2D shineShaderMask;\nlayout(std140) uniform RATE{\n  vec4 shineColor;\n  float shineSaturation;\n  float shineContrast;\n  float shineRotation;\n  float timeScale;\n  float shineSpeed;\n  float shineScale;\n  float shineWidth;\n  float shineSmoothness;\n  float shineFade;\n};\nvec3 RotateAroundAxis( vec3 center, vec3 original, vec3 u, float angle )\n{\n  original -= center;\n  float C = cos( angle );\n  float S = sin( angle );\n  float t = 1.0 - C;\n  float m00 = t * u.x * u.x + C;\n  float m01 = t * u.x * u.y - S * u.z;\n  float m02 = t * u.x * u.z + S * u.y;\n  float m10 = t * u.x * u.y + S * u.z;\n  float m11 = t * u.y * u.y + C;\n  float m12 = t * u.y * u.z - S * u.x;\n  float m20 = t * u.x * u.z - S * u.y;\n  float m21 = t * u.y * u.z + S * u.x;\n  float m22 = t * u.z * u.z + C;\n  mat3 finalMatrix = mat3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );\n  return finalMatrix*original + center;\n}\nvec4 frag () {\n  vec4 source = texture( cc_spriteTexture, uv0 );\n  vec3 mean = vec3(( source.x + source.y + source.z ) / 3.0 );\n  vec3 m1 = mix( mean , source.rgb , shineSaturation);\n  vec3 m2 = max( m1 , 0.0001 );\n  vec3 contrast = vec3(max( shineContrast , 0.001 ));\n  float tscale =cc_time.x * timeScale;\n  vec2 uvoffset = uv0;\n  vec3 sinspace = RotateAroundAxis( vec3( 0,0,0 ), vec3( ( ( tscale * shineSpeed ) + ( shineScale * uvoffset ) ) ,  0.0 ), vec3( 0,0,1 ), ( ( shineRotation / 360.0 ) * PI ) );\n  float sinWidth = ( shineWidth + -1.0 );\n  float a1 = clamp( ( ( ( sin( ( ( sinspace.x + sinspace.y ) * 10.0 ) ) + sinWidth ) * ( 2.0 - sinWidth ) ) * shineSmoothness ) , 0.0 , 1.0 );\n  vec4 mask = texture( shineShaderMask, uv0 );\n  vec4 c = vec4(( source.rgb + ( ( pow( m2 , contrast ) * (shineColor).rgb ) * a1 * ( shineFade * ( mask.r * mask.a ) ) ) ) , (source).a)*color;\n  c.rgb *= c.a;\n  ALPHA_TEST(c);\n  return c;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp mat4 cc_matViewProj;\n#if USE_LOCAL\n  uniform highp mat4 cc_matWorld;\n#endif\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying vec4 color;\nvarying vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matWorld * pos;\n  #endif\n  #if USE_PIXEL_ALIGNMENT\n    pos = cc_matView * pos;\n    pos.xyz = floor(pos.xyz);\n    pos = cc_matProj * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nuniform highp vec4 cc_time;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#if USE_ALPHA_TEST\n      uniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n    if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n    if (alpha < alphaThreshold) discard;\n  #endif\n}\nvarying vec4 color;\nvarying vec2 uv0;\nuniform sampler2D cc_spriteTexture;\nuniform sampler2D shineShaderMask;\n    uniform vec4 shineColor;\n    uniform float shineSaturation;\n    uniform float shineContrast;\n    uniform float shineRotation;\n    uniform float timeScale;\n    uniform float shineSpeed;\n    uniform float shineScale;\n    uniform float shineWidth;\n    uniform float shineSmoothness;\n    uniform float shineFade;\nvec3 RotateAroundAxis( vec3 center, vec3 original, vec3 u, float angle )\n{\n  original -= center;\n  float C = cos( angle );\n  float S = sin( angle );\n  float t = 1.0 - C;\n  float m00 = t * u.x * u.x + C;\n  float m01 = t * u.x * u.y - S * u.z;\n  float m02 = t * u.x * u.z + S * u.y;\n  float m10 = t * u.x * u.y + S * u.z;\n  float m11 = t * u.y * u.y + C;\n  float m12 = t * u.y * u.z - S * u.x;\n  float m20 = t * u.x * u.z - S * u.y;\n  float m21 = t * u.y * u.z + S * u.x;\n  float m22 = t * u.z * u.z + C;\n  mat3 finalMatrix = mat3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );\n  return finalMatrix*original + center;\n}\nvec4 frag () {\n  vec4 source = texture2D(cc_spriteTexture, uv0 );\n  vec3 mean = vec3(( source.x + source.y + source.z ) / 3.0 );\n  vec3 m1 = mix( mean , source.rgb , shineSaturation);\n  vec3 m2 = max( m1 , 0.0001 );\n  vec3 contrast = vec3(max( shineContrast , 0.001 ));\n  float tscale =cc_time.x * timeScale;\n  vec2 uvoffset = uv0;\n  vec3 sinspace = RotateAroundAxis( vec3( 0,0,0 ), vec3( ( ( tscale * shineSpeed ) + ( shineScale * uvoffset ) ) ,  0.0 ), vec3( 0,0,1 ), ( ( shineRotation / 360.0 ) * PI ) );\n  float sinWidth = ( shineWidth + -1.0 );\n  float a1 = clamp( ( ( ( sin( ( ( sinspace.x + sinspace.y ) * 10.0 ) ) + sinWidth ) * ( 2.0 - sinWidth ) ) * shineSmoothness ) , 0.0 , 1.0 );\n  vec4 mask = texture2D(shineShaderMask, uv0 );\n  vec4 c = vec4(( source.rgb + ( ( pow( m2 , contrast ) * (shineColor).rgb ) * a1 * ( shineFade * ( mask.r * mask.a ) ) ) ) , (source).a)*color;\n  c.rgb *= c.a;\n  ALPHA_TEST(c);\n  return c;\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["USE_LOCAL"]}],"samplerTextures":[{"name":"cc_spriteTexture","defines":[]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":49,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":50}},"defines":[{"name":"USE_LOCAL","type":"boolean","defines":[]},{"name":"USE_PIXEL_ALIGNMENT","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]}]}],[{"passes":[{"program":"../shader/Shine|s-vs:vert|s-fs:frag","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"rasterizerState":{"cullMode":0},"depthStencilState":{"depthTest":false,"depthWrite":false},"properties":{"shineShaderMask":{"value":"grey","type":28},"shineColor":{"type":16,"value":[1,1,0,0],"editor":{"type":"color"}},"shineSaturation":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]}},"shineContrast":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]}},"shineRotation":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,360]}},"timeScale":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]}},"shineSpeed":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]}},"shineScale":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]}},"shineWidth":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]}},"shineSmoothness":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]}},"shineFade":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]}}}}]}]]],0,0,[],[],[]],[[{"name":"5","rect":{"x":0,"y":0,"width":495,"height":259},"offset":{"x":-0.5,"y":0.5},"originalSize":{"width":496,"height":260},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[1],[2]],[[[18,"fameland"],[19,"fameland",33554432,[-19,-20,-21,-22,-23,-24,-25,-26,-27,-28],[[2,-2,[0,"b6y/4peeFDWI1Fd4o6SNcG"],[5,240,120]],[22,-17,[0,"0a7Apbh5NCz5sj3QIn9EwR"],[6,7,8,9,10,11],-16,-15,-14,-13,-12,-11,-10,-9,[-5,-6,-7,-8],-4,[12,13,14],[15,16,17,18],-3],[23,-18,[0,"9154JCVz1KkI9+8rEDlOUF"],[[[0,-260,0],[0,0,160],[0,260,0],[0,0,-160]],8,8,8,8]]],[24,"6dYAYJYThA6KHLTfSSg84N",[],-1,0]],[12,"plantAni",33554432,1,[-30,-31,-32,-33],[[2,-29,[0,"10vaRTUDdCKaMvJvfiTHYq"],[5,460,300]]],[1,null,"52sqazMXhHq59thBvjUgyw",0]],[13,"Fruit",33554432,1,[-36,-37,-38],[[5,-35,[0,"e3d2D+uo1OPb8lagkBlmc2"]]],[7,"30WA4CHVJJ16pT5JMHcKot",-34,0],[1,12.059,174.708,0]],[12,"plant",33554432,1,[-40,-41,-42,-43],[[2,-39,[0,"31JyZxnXtNY5GDbPAigfwn"],[5,460,300]]],[1,null,"34vwAQtwZGyqo3T1MmlfD4",0]],[13,"ex",33554432,1,[-45,-46],[[5,-44,[0,"11TxiHG61IEY1iUi7yFSir"]]],[1,null,"19dVf7xkRDPaXZOeXChnvW",0],[1,14.816,286.084,0]],[13,"Chuizi",33554432,1,[-49],[[5,-47,[0,"f9QnThAS5AV4VCWtFmCuXs"]],[25,3,-48,[0,"28PjQx0uhI7YqMk+cvJYB5"],[[26,"2fe55IH1ZVM0rtWR5LxaCTD","chuZiClick",1]]]],[7,"bfv9txRUhJR6teB+LMWiS9",1,0],[1,15.767,176.977,0]],[4,"plant",33554432,4,[[[6,-50,[0,"fcxZ5tmXVMgqVSyo/aiOWG"],[5,360,360],[0,0.5,0]],-51,[11,-52,[0,"30ZqUyAEpKCKN+3QdTHX/k"]]],4,1,4],[1,null,"bdJGzlCr5E25Vb2Wr/0/kq",0],[1,19.426,10.209,0]],[4,"plant-002",33554432,4,[[[6,-53,[0,"d8kJTSiG1BcpCqsUkXYQ1u"],[5,360,360],[0,0.5,0]],-54,[11,-55,[0,"79HCEViFZNKKAsJhK8tri+"]]],4,1,4],[1,null,"26kZ4hopRMDb2ZsWO5zgQQ",0],[1,-108.907,-47.298,0]],[4,"plant-001",33554432,4,[[[6,-56,[0,"f40PS9L2xMQJwHmzhEmtx7"],[5,360,360],[0,0.5,0]],-57,[11,-58,[0,"12G7uOmXtMgqi8zJLJZWxa"]]],4,1,4],[1,null,"8cFQZDW+dF3pgXGV9PZdTM",0],[1,135.147,-51.307,0]],[4,"plant-003",33554432,4,[[[6,-59,[0,"c5CGuzxpZAQIu5X4uEmmzx"],[5,360,360],[0,0.5,0]],-60,[11,-61,[0,"d8rQfD6UpASqOknQfwJqcu"]]],4,1,4],[1,null,"a63mLkqa9AK7dgdH2FxRlV",0],[1,15.257,-113.182,0]],[16,"bg",33554432,5,[[2,-62,[0,"8cuYz9p+hH8bmF3Dno9o4g"],[5,103,126]],[8,-63,[0,"10IQK9vFtOBo6+jilZ4g+x"],0],[17,-64,[0,"f4lUO+NPVKnJPdksDNdlI3"]]],[1,null,"823+N0O1hLYr3RPGxmVqRN",0]],[4,"image",33554432,5,[[[2,-65,[0,"c3qkdmjmxOQrGHbAZqz/B4"],[5,94,95]],-66,[17,-67,[0,"a9HRWdgDJGMalaEyjdHWLM"]]],4,1,4],[1,null,"f3yaMuxJJMhL9PlAsu5/l6",0],[1,0,11.583,0]],[3,"Label",33554432,3,[[6,-68,[0,"ba82Nu6v9FRYzuQ9c65cC6"],[5,100.17,54.4],[0,0,0.5]],[27,"X100",40,false,1,-69,[0,"42WARyikREkZwJjjbK5ycI"],[4,4282241279],3],[28,-70,[0,"c6A4d24pRAMaNf42mH+ZKg"],[4,4278266574]]],[1,null,"2fjZkaey5HL4jZm/BRzgzc",0],[1,60.124,10.931,0]],[12,"dikuang2 (2)",33554432,6,[-73],[[2,-71,[0,"fdq84teSNGerRXD52qJJaj"],[5,103,126]],[8,-72,[0,"d28h38fchPgponI4AtWJAJ"],5]],[7,"f0OcYVh31MJ6ef0/rfcVnx",1,0]],[20,"land",33554432,1,[[[2,-74,[0,"c9f15X3m1Gm6FgooS0XPTz"],[5,496,260]],-75],4,1],[1,null,"d7hLd8IutEuZ0m/v/dRlcI",0]],[4,"select",33554432,1,[[[2,-76,[0,"0cOb+VzPlK5qF4CMpy0kd1"],[5,526,274]],-77],4,1],[1,null,"7bc0XrTttPlpRdfN8+p3/h",0],[1,-4.938,-4.939,0]],[21,"lock",false,33554432,1,[[[2,-78,[0,"6fYYnIDkJKtrOhAilNvjuI"],[5,496,260]],-79],4,1],[1,null,"7eicKqD1dPlL5ug1ElK8Gu",0],[1,8.693,4.347,0]],[3,"effect",33554432,1,[[5,-80,[0,"59j/c5VRxL2qyQ2MgICsfd"]]],[1,null,"2cnqGLHE9GEL6G6QTBiUpI",0],[1,4.939,7.408,0]],[16,"Sprite-001",33554432,3,[[2,-81,[0,"292JIyVwxBg63RPP10Fu5Q"],[5,103,126]],[8,-82,[0,"f9O/xs1JZH4bgEPgLVxnJO"],1]],[7,"b6gjaKj7RGE6W6PbGAnsPj",1,0]],[3,"Sprite",33554432,3,[[2,-83,[0,"77AhRsgZZBh4NsUuHmNAlK"],[5,77,93]],[8,-84,[0,"0b4ArVaFJKvKAZK5bjH9Ra"],2]],[1,null,"31olbtN75BZb11B6hCbJkM",0],[1,0,10.365,0]],[3,"headEffect",33554432,1,[[5,-85,[0,"3fEt/kJG9HIayL7eg07IDB"]]],[1,null,"a0azin4eFGe5d66ATom11G",0],[1,-34.57,217.202,0]],[3,"chuizi",33554432,14,[[2,-86,[0,"52iM1WnSRMT47wU0/2C6zy"],[5,74,81]],[8,-87,[0,"ebsLuhiHlO3qnpALvRv2D4"],4]],[7,"1a6za0oSBE1aCjR5b3o7v/",1,0],[1,1.431,10.738,0]],[14,2,15,[0,"43ih9Bx9NPWJ3pxwWvruJG"]],[9,16,[0,"00wRyjGQJGyKibVLWs4+au"]],[9,7,[0,"b2azDHbrtNzKsiUQ49uGMc"]],[9,8,[0,"64Qq6aZdxGt7zB8atRRFMu"]],[9,9,[0,"0fWpIU9UtL0IEUXLd73kN+"]],[9,10,[0,"92dE8p121Nkp7eaBO2wtL4"]],[3,"plant",33554432,2,[[2,-88,[0,"277Ni/6ZNHcIMIUBOnBg2F"],[5,360,360]]],[1,null,"2cm+Fy189Kz4Rslws57YQC",0],[1,5.021,111.866,0]],[3,"plant-002",33554432,2,[[2,-89,[0,"72JHCd8UpAvZc9AuSmOtxu"],[5,206,288]]],[1,null,"c8vafIMsJLJ6GUp149N7WK",0],[1,-118.728,65.259,0]],[3,"plant-001",33554432,2,[[2,-90,[0,"9eU2lEz3pNGKyfswsDCKeb"],[5,206,288]]],[1,null,"deKBTNt4NJTbEWNkVNL6NE",0],[1,135.147,67.255,0]],[3,"plant-003",33554432,2,[[2,-91,[0,"934cs1RQNB/4U8434m3i25"],[5,206,288]]],[1,null,"96Cnixf8pDEqfFkiFyW6SL",0],[1,6.839,37.493,0]],[14,2,17,[0,"dbK3I119dOgrk61FQgzdZz"]],[14,0,12,[0,"38wICjvRJARLnlV6muLjnX"]]],0,[0,4,1,0,0,1,0,5,6,0,6,2,0,-1,25,0,-2,27,0,-3,26,0,-4,28,0,7,3,0,8,21,0,9,18,0,10,33,0,11,24,0,12,23,0,13,5,0,14,34,0,0,1,0,0,1,0,-1,15,0,-2,16,0,-3,4,0,-4,2,0,-5,17,0,-6,18,0,-7,5,0,-8,3,0,-9,21,0,-10,6,0,0,2,0,-1,29,0,-2,30,0,-3,31,0,-4,32,0,4,3,0,0,3,0,-1,19,0,-2,20,0,-3,13,0,0,4,0,-1,7,0,-2,8,0,-3,9,0,-4,10,0,0,5,0,-1,11,0,-2,12,0,0,6,0,0,6,0,-1,14,0,0,7,0,-2,25,0,0,7,0,0,8,0,-2,26,0,0,8,0,0,9,0,-2,27,0,0,9,0,0,10,0,-2,28,0,0,10,0,0,11,0,0,11,0,0,11,0,0,12,0,-2,34,0,0,12,0,0,13,0,0,13,0,0,13,0,0,14,0,0,14,0,-1,22,0,0,15,0,-2,23,0,0,16,0,-2,24,0,0,17,0,-2,33,0,0,18,0,0,19,0,0,19,0,0,20,0,0,20,0,0,21,0,0,22,0,0,22,0,0,29,0,0,30,0,0,31,0,0,32,0,15,1,91],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,23,24,33,34],[2,2,2,16,2,2,-1,-2,-3,-4,-5,-6,-1,-2,-3,-1,-2,-3,-4,2,2,2,2],[0,0,3,4,5,0,6,1,7,8,9,10,11,12,13,14,15,16,17,1,18,19,20]],[[{"name":"2","rect":{"x":0,"y":0,"width":495,"height":259},"offset":{"x":-0.5,"y":0.5},"originalSize":{"width":496,"height":260},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[1],[21]],[[{"name":"8","rect":{"x":0,"y":0,"width":496,"height":260},"offset":{"x":0,"y":0},"originalSize":{"width":496,"height":260},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[1],[22]],[[[10,"../shader/Add Hue",[{"hash":979167108,"name":"../shader/Add Hue|s-vs:vert|s-fs:frag","blocks":[{"name":"ALPHA_TEST_DATA","stageFlags":16,"binding":0,"members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"]},{"name":"RATE","stageFlags":16,"binding":1,"members":[{"name":"addHueBrightness","type":13,"count":1},{"name":"addHueSaturation","type":13,"count":1},{"name":"addHueSpeed","type":13,"count":1},{"name":"timeScale","type":13,"count":1},{"name":"addHueContrast","type":13,"count":1},{"name":"addHueFade","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"hueShaderMask","type":28,"count":1,"stageFlags":16,"binding":2,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":21,"location":1,"defines":[]},{"name":"a_color","format":44,"location":2,"defines":[]}],"varyings":[{"name":"color","type":16,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"uv0","type":14,"count":1,"stageFlags":17,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if USE_LOCAL\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n  };\n#endif\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec2 a_texCoord;\nlayout(location = 2) in vec4 a_color;\nlayout(location = 0) out vec4 color;\nlayout(location = 1) out vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matWorld * pos;\n  #endif\n  #if USE_PIXEL_ALIGNMENT\n    pos = cc_matView * pos;\n    pos.xyz = floor(pos.xyz);\n    pos = cc_matProj * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#if USE_ALPHA_TEST\n  layout(set = 1, binding = 0) uniform ALPHA_TEST_DATA {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n    if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n    if (alpha < alphaThreshold) discard;\n  #endif\n}\nlayout(location = 0) in vec4 color;\nlayout(location = 1) in vec2 uv0;\nlayout(set = 2, binding = 11) uniform sampler2D cc_spriteTexture;\nlayout(set = 1, binding = 2) uniform sampler2D hueShaderMask;\nlayout(set = 1, binding = 1) uniform RATE{\n  float addHueBrightness;\n  float addHueSaturation;\n  float addHueSpeed;\n  float timeScale;\n  float addHueContrast;\n  float addHueFade;\n};\nvec3 RGB2HSV(vec3 c)\n{\n  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n  vec4 p = mix( vec4( c.bg, K.wz ), vec4( c.gb, K.xy ), step( c.b, c.g ) );\n  vec4 q = mix( vec4( p.xyw, c.r ), vec4( c.r, p.yzx ), step( p.x, c.r ) );\n  float d = q.x - min( q.w, q.y );\n  float e = 1.0e-10;\n  return vec3( abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 HSV2RGB(vec3 c)\n{\n  vec4 K = vec4( 1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0 );\n  vec3 p = abs( fract( vec3(c.x,c.x,c.x) + K.xyz ) * 6.0 - vec3(K.w,K.w,K.w));\n  return c.z * mix( vec3(K.x,K.x,K.x), clamp(p - vec3(K.x,K.x,K.x), 0.0, 1.0), c.y );\n}\nvec4 frag () {\n  float tscale = cc_time.x * timeScale;\n  vec3 h1 = HSV2RGB( vec3((tscale * addHueSpeed ),1.0,1.0) );\n  vec3 r1 = RGB2HSV(h1);\n  vec3 hsv = HSV2RGB( vec3(r1.x,addHueSaturation,( r1.z * addHueBrightness )) );\n  vec4 source = texture( cc_spriteTexture, uv0 );\n  float mean = max( ( ( source.x + source.y + source.z ) / 3.0 ) , 0.0001 );\n  vec4 maskcolor = texture(hueShaderMask, uv0);\n  vec4 relust = (vec4(( ( hsv * pow( mean , max( addHueContrast , 0.001 ) ) * (addHueFade * ( maskcolor.r * maskcolor.a ) ) ) + (source).rgb ) , source.a));\n  vec4 c = ( relust * color );\n  ALPHA_TEST(c);\n  return c;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if USE_LOCAL\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n  };\n#endif\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nout vec4 color;\nout vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matWorld * pos;\n  #endif\n  #if USE_PIXEL_ALIGNMENT\n    pos = cc_matView * pos;\n    pos.xyz = floor(pos.xyz);\n    pos = cc_matProj * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#if USE_ALPHA_TEST\n  layout(std140) uniform ALPHA_TEST_DATA {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n    if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n    if (alpha < alphaThreshold) discard;\n  #endif\n}\nin vec4 color;\nin vec2 uv0;\nuniform sampler2D cc_spriteTexture;\nuniform sampler2D hueShaderMask;\nlayout(std140) uniform RATE{\n  float addHueBrightness;\n  float addHueSaturation;\n  float addHueSpeed;\n  float timeScale;\n  float addHueContrast;\n  float addHueFade;\n};\nvec3 RGB2HSV(vec3 c)\n{\n  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n  vec4 p = mix( vec4( c.bg, K.wz ), vec4( c.gb, K.xy ), step( c.b, c.g ) );\n  vec4 q = mix( vec4( p.xyw, c.r ), vec4( c.r, p.yzx ), step( p.x, c.r ) );\n  float d = q.x - min( q.w, q.y );\n  float e = 1.0e-10;\n  return vec3( abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 HSV2RGB(vec3 c)\n{\n  vec4 K = vec4( 1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0 );\n  vec3 p = abs( fract( vec3(c.x,c.x,c.x) + K.xyz ) * 6.0 - vec3(K.w,K.w,K.w));\n  return c.z * mix( vec3(K.x,K.x,K.x), clamp(p - vec3(K.x,K.x,K.x), 0.0, 1.0), c.y );\n}\nvec4 frag () {\n  float tscale = cc_time.x * timeScale;\n  vec3 h1 = HSV2RGB( vec3((tscale * addHueSpeed ),1.0,1.0) );\n  vec3 r1 = RGB2HSV(h1);\n  vec3 hsv = HSV2RGB( vec3(r1.x,addHueSaturation,( r1.z * addHueBrightness )) );\n  vec4 source = texture( cc_spriteTexture, uv0 );\n  float mean = max( ( ( source.x + source.y + source.z ) / 3.0 ) , 0.0001 );\n  vec4 maskcolor = texture(hueShaderMask, uv0);\n  vec4 relust = (vec4(( ( hsv * pow( mean , max( addHueContrast , 0.001 ) ) * (addHueFade * ( maskcolor.r * maskcolor.a ) ) ) + (source).rgb ) , source.a));\n  vec4 c = ( relust * color );\n  ALPHA_TEST(c);\n  return c;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp mat4 cc_matViewProj;\n#if USE_LOCAL\n  uniform highp mat4 cc_matWorld;\n#endif\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying vec4 color;\nvarying vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matWorld * pos;\n  #endif\n  #if USE_PIXEL_ALIGNMENT\n    pos = cc_matView * pos;\n    pos.xyz = floor(pos.xyz);\n    pos = cc_matProj * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nuniform highp vec4 cc_time;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#if USE_ALPHA_TEST\n      uniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n    if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n    if (alpha < alphaThreshold) discard;\n  #endif\n}\nvarying vec4 color;\nvarying vec2 uv0;\nuniform sampler2D cc_spriteTexture;\nuniform sampler2D hueShaderMask;\n    uniform float addHueBrightness;\n    uniform float addHueSaturation;\n    uniform float addHueSpeed;\n    uniform float timeScale;\n    uniform float addHueContrast;\n    uniform float addHueFade;\nvec3 RGB2HSV(vec3 c)\n{\n  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n  vec4 p = mix( vec4( c.bg, K.wz ), vec4( c.gb, K.xy ), step( c.b, c.g ) );\n  vec4 q = mix( vec4( p.xyw, c.r ), vec4( c.r, p.yzx ), step( p.x, c.r ) );\n  float d = q.x - min( q.w, q.y );\n  float e = 1.0e-10;\n  return vec3( abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 HSV2RGB(vec3 c)\n{\n  vec4 K = vec4( 1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0 );\n  vec3 p = abs( fract( vec3(c.x,c.x,c.x) + K.xyz ) * 6.0 - vec3(K.w,K.w,K.w));\n  return c.z * mix( vec3(K.x,K.x,K.x), clamp(p - vec3(K.x,K.x,K.x), 0.0, 1.0), c.y );\n}\nvec4 frag () {\n  float tscale = cc_time.x * timeScale;\n  vec3 h1 = HSV2RGB( vec3((tscale * addHueSpeed ),1.0,1.0) );\n  vec3 r1 = RGB2HSV(h1);\n  vec3 hsv = HSV2RGB( vec3(r1.x,addHueSaturation,( r1.z * addHueBrightness )) );\n  vec4 source = texture2D(cc_spriteTexture, uv0 );\n  float mean = max( ( ( source.x + source.y + source.z ) / 3.0 ) , 0.0001 );\n  vec4 maskcolor = texture2D(hueShaderMask, uv0);\n  vec4 relust = (vec4(( ( hsv * pow( mean , max( addHueContrast , 0.001 ) ) * (addHueFade * ( maskcolor.r * maskcolor.a ) ) ) + (source).rgb ) , source.a));\n  vec4 c = ( relust * color );\n  ALPHA_TEST(c);\n  return c;\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["USE_LOCAL"]}],"samplerTextures":[{"name":"cc_spriteTexture","defines":[]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":49,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":46}},"defines":[{"name":"USE_LOCAL","type":"boolean","defines":[]},{"name":"USE_PIXEL_ALIGNMENT","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]}]}],[{"passes":[{"program":"../shader/Add Hue|s-vs:vert|s-fs:frag","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"rasterizerState":{"cullMode":0},"depthStencilState":{"depthTest":false,"depthWrite":false},"properties":{"hueShaderMask":{"value":"grey","type":28},"addHueBrightness":{"type":13,"value":[2],"editor":{"slide":true,"step":0.01,"range":[0,5]}},"addHueSaturation":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.01,"range":[0,2]}},"addHueSpeed":{"type":13,"value":[1],"editor":{"slide":true,"step":0.01,"range":[0,10]}},"timeScale":{"type":13,"value":[1],"editor":{"slide":true,"step":0.01,"range":[0,1]}},"addHueContrast":{"type":13,"value":[1],"editor":{"slide":true,"step":0.01,"range":[0,1]}},"addHueFade":{"type":13,"value":[1],"editor":{"slide":true,"step":0.01,"range":[0,1]}}}}]}]]],0,0,[],[],[]],[[{"name":"1","rect":{"x":13,"y":0,"width":460,"height":249},"offset":{"x":-5,"y":5.5},"originalSize":{"width":496,"height":260},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[1],[23]],[[[29,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{"shineSaturation":0.907,"shineContrast":0,"shineRotation":153,"timeScale":0.754,"shineSpeed":0.837,"shineScale":1,"shineWidth":0.825,"shineFade":0.925},"shineColor",8,[4,4294967295]]],11]]],0,0,[0],[3],[24]],[[{"name":"3","rect":{"x":0,"y":0,"width":495,"height":259},"offset":{"x":-0.5,"y":0.5},"originalSize":{"width":496,"height":260},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[1],[25]],[[[15,[{"windRotationWindFactor":0.68,"WindMinIntensity":-0.088,"WindMaxIntensity":0.076,"windXPosition":-60,"WindNoiseSpeed":4.015,"WindNoiseScale":0.401,"windRotation":0.342,"windMaxRotation":1,"windFlip":-0.774,"windSquishFactor":0,"windSquishWindFactor":0}],[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_PIXEL_ALIGNMENT":true,"USE_ALPHA_TEST":true}]]],0,0,[0],[3],[26]],[[[10,"../shader/Wind",[{"hash":3432625096,"name":"../shader/Wind|s-vs:vert|s-fs:frag","blocks":[{"name":"ALPHA_TEST_DATA","stageFlags":16,"binding":0,"members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"]},{"name":"RATE","stageFlags":16,"binding":1,"members":[{"name":"windRotationWindFactor","type":13,"count":1},{"name":"WindMinIntensity","type":13,"count":1},{"name":"WindMaxIntensity","type":13,"count":1},{"name":"windXPosition","type":13,"count":1},{"name":"WindNoiseSpeed","type":13,"count":1},{"name":"WindNoiseScale","type":13,"count":1},{"name":"windRotation","type":13,"count":1},{"name":"windMaxRotation","type":13,"count":1},{"name":"windFlip","type":13,"count":1},{"name":"windSquishFactor","type":13,"count":1},{"name":"windSquishWindFactor","type":13,"count":1}],"defines":[]}],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":21,"location":1,"defines":[]},{"name":"a_color","format":44,"location":2,"defines":[]}],"varyings":[{"name":"color","type":16,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"uv0","type":14,"count":1,"stageFlags":17,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\n  precision highp float;\n  layout(set = 0, binding = 0) uniform CCGlobal {\n    highp   vec4 cc_time;\n    mediump vec4 cc_screenSize;\n    mediump vec4 cc_nativeSize;\n  };\n  layout(set = 0, binding = 1) uniform CCCamera {\n    highp   mat4 cc_matView;\n    highp   mat4 cc_matViewInv;\n    highp   mat4 cc_matProj;\n    highp   mat4 cc_matProjInv;\n    highp   mat4 cc_matViewProj;\n    highp   mat4 cc_matViewProjInv;\n    highp   vec4 cc_cameraPos;\n    mediump vec4 cc_screenScale;\n    mediump vec4 cc_exposure;\n    mediump vec4 cc_mainLitDir;\n    mediump vec4 cc_mainLitColor;\n    mediump vec4 cc_ambientSky;\n    mediump vec4 cc_ambientGround;\n    mediump vec4 cc_fogColor;\n    mediump vec4 cc_fogBase;\n    mediump vec4 cc_fogAdd;\n    mediump vec4 cc_nearFar;\n    mediump vec4 cc_viewPort;\n  };\n  #if USE_LOCAL\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n  #if SAMPLE_FROM_RT\n    #define QUATER_PI         0.78539816340\n    #define HALF_PI           1.57079632679\n    #define PI                3.14159265359\n    #define PI2               6.28318530718\n    #define PI4               12.5663706144\n    #define INV_QUATER_PI     1.27323954474\n    #define INV_HALF_PI       0.63661977237\n    #define INV_PI            0.31830988618\n    #define INV_PI2           0.15915494309\n    #define INV_PI4           0.07957747155\n    #define EPSILON           1e-6\n    #define EPSILON_LOWP      1e-4\n    #define LOG2              1.442695\n    #define EXP_VALUE         2.71828183f\n    #define FP_MAX            65504.0\n    #define FP_SCALE          0.0009765625\n    #define FP_SCALE_INV      1024.0\n    #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n  #endif\n  layout(location = 0) in vec3 a_position;\n  layout(location = 1) in vec2 a_texCoord;\n  layout(location = 2) in vec4 a_color;\n  layout(location = 0) out vec4 color;\n  layout(location = 1) out vec2 uv0;\n  vec4 vert () {\n    vec4 pos = vec4(a_position, 1);\n    #if USE_LOCAL\n      pos = cc_matWorld * pos;\n    #endif\n    #if USE_PIXEL_ALIGNMENT\n      pos = cc_matView * pos;\n      pos.xyz = floor(pos.xyz);\n      pos = cc_matProj * pos;\n    #else\n      pos = cc_matViewProj * pos;\n    #endif\n    uv0 = a_texCoord;\n#if SAMPLE_FROM_RT\n      uv0 = cc_cameraPos.w > 1.0 ? vec2(uv0.x, 1.0 - uv0.y) : uv0;\n#endif\n    color = a_color;\n    return pos;\n  }\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#if USE_ALPHA_TEST\n  layout(set = 1, binding = 0) uniform ALPHA_TEST_DATA {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n    if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n    if (alpha < alphaThreshold) discard;\n  #endif\n}\nlayout(location = 0) in vec4 color;\nlayout(location = 1) in vec2 uv0;\nlayout(set = 2, binding = 11) uniform sampler2D cc_spriteTexture;\nlayout(set = 1, binding = 1) uniform RATE{\n  float windRotationWindFactor;\n  float WindMinIntensity;\n  float WindMaxIntensity;\n  float windXPosition;\n  float WindNoiseSpeed;\n  float WindNoiseScale;\n  float windRotation;\n  float windMaxRotation;\n  float windFlip;\n  float windSquishFactor;\n  float windSquishWindFactor;\n};\nfloat FastNoise101_g1( float x )\n{\n  float i = floor(x);\n  float f = fract(x);\n  float s = sign(fract(x/2.0)-0.5);\n  float k = 0.5+0.5*sin(i);\n  return s*f*(f-1.0)*((16.0*k-4.0)*f*(f-1.0)-1.0);\n}\nvec3 RotateAroundAxis( vec3 center, vec3 original, vec3 u, float angle )\n{\n  original -= center;\n  float C = cos( angle );\n  float S = sin( angle );\n  float t = 1.0 - C;\n  float m00 = t * u.x * u.x + C;\n  float m01 = t * u.x * u.y - S * u.z;\n  float m02 = t * u.x * u.z + S * u.y;\n  float m10 = t * u.x * u.y + S * u.z;\n  float m11 = t * u.y * u.y + C;\n  float m12 = t * u.y * u.z - S * u.x;\n  float m20 = t * u.x * u.z - S * u.y;\n  float m21 = t * u.y * u.z + S * u.x;\n  float m22 = t * u.z * u.z + C;\n  mat3 finalMatrix = mat3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );\n  return finalMatrix*original + center;\n}\nvec4 frag () {\n  float xoffset = windXPosition;\n  float noise = ( ( xoffset + ( cc_time.x * WindNoiseSpeed ) ) * WindNoiseScale );\n  float fastnoise = FastNoise101_g1(noise);\n  float intensity = mix( WindMinIntensity , WindMaxIntensity , ( fastnoise + 0.5 ));\n  float factor = clamp( ( ( windRotationWindFactor * intensity ) + windRotation ) , -windMaxRotation , windMaxRotation );\n  float winflipy = ( uv0.y + windFlip );\n  vec3 d1 = (vec3(0.5 , -windFlip , 0.0));\n  vec2 d2 = (vec2(0.0 , ( windSquishFactor * min( ( ( windSquishWindFactor * abs( intensity ) ) + abs( windRotation ) ) , windMaxRotation ) * winflipy )));\n  vec3 newuv = RotateAroundAxis( d1, vec3( ( d2 + uv0 ) ,  0.0 ), vec3( 0,0,1 ), ( factor * winflipy ) );\n  vec4 c = texture( cc_spriteTexture,newuv.xy ) * color;\n  c.rgb *= c.a;\n  ALPHA_TEST(c);\n  return c;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\n  precision highp float;\n  layout(std140) uniform CCGlobal {\n    highp   vec4 cc_time;\n    mediump vec4 cc_screenSize;\n    mediump vec4 cc_nativeSize;\n  };\n  layout(std140) uniform CCCamera {\n    highp   mat4 cc_matView;\n    highp   mat4 cc_matViewInv;\n    highp   mat4 cc_matProj;\n    highp   mat4 cc_matProjInv;\n    highp   mat4 cc_matViewProj;\n    highp   mat4 cc_matViewProjInv;\n    highp   vec4 cc_cameraPos;\n    mediump vec4 cc_screenScale;\n    mediump vec4 cc_exposure;\n    mediump vec4 cc_mainLitDir;\n    mediump vec4 cc_mainLitColor;\n    mediump vec4 cc_ambientSky;\n    mediump vec4 cc_ambientGround;\n    mediump vec4 cc_fogColor;\n    mediump vec4 cc_fogBase;\n    mediump vec4 cc_fogAdd;\n    mediump vec4 cc_nearFar;\n    mediump vec4 cc_viewPort;\n  };\n  #if USE_LOCAL\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n  #if SAMPLE_FROM_RT\n    #define QUATER_PI         0.78539816340\n    #define HALF_PI           1.57079632679\n    #define PI                3.14159265359\n    #define PI2               6.28318530718\n    #define PI4               12.5663706144\n    #define INV_QUATER_PI     1.27323954474\n    #define INV_HALF_PI       0.63661977237\n    #define INV_PI            0.31830988618\n    #define INV_PI2           0.15915494309\n    #define INV_PI4           0.07957747155\n    #define EPSILON           1e-6\n    #define EPSILON_LOWP      1e-4\n    #define LOG2              1.442695\n    #define EXP_VALUE         2.71828183f\n    #define FP_MAX            65504.0\n    #define FP_SCALE          0.0009765625\n    #define FP_SCALE_INV      1024.0\n    #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n  #endif\n  in vec3 a_position;\n  in vec2 a_texCoord;\n  in vec4 a_color;\n  out vec4 color;\n  out vec2 uv0;\n  vec4 vert () {\n    vec4 pos = vec4(a_position, 1);\n    #if USE_LOCAL\n      pos = cc_matWorld * pos;\n    #endif\n    #if USE_PIXEL_ALIGNMENT\n      pos = cc_matView * pos;\n      pos.xyz = floor(pos.xyz);\n      pos = cc_matProj * pos;\n    #else\n      pos = cc_matViewProj * pos;\n    #endif\n    uv0 = a_texCoord;\n#if SAMPLE_FROM_RT\n      uv0 = cc_cameraPos.w > 1.0 ? vec2(uv0.x, 1.0 - uv0.y) : uv0;\n#endif\n    color = a_color;\n    return pos;\n  }\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#if USE_ALPHA_TEST\n  layout(std140) uniform ALPHA_TEST_DATA {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n    if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n    if (alpha < alphaThreshold) discard;\n  #endif\n}\nin vec4 color;\nin vec2 uv0;\nuniform sampler2D cc_spriteTexture;\nlayout(std140) uniform RATE{\n  float windRotationWindFactor;\n  float WindMinIntensity;\n  float WindMaxIntensity;\n  float windXPosition;\n  float WindNoiseSpeed;\n  float WindNoiseScale;\n  float windRotation;\n  float windMaxRotation;\n  float windFlip;\n  float windSquishFactor;\n  float windSquishWindFactor;\n};\nfloat FastNoise101_g1( float x )\n{\n  float i = floor(x);\n  float f = fract(x);\n  float s = sign(fract(x/2.0)-0.5);\n  float k = 0.5+0.5*sin(i);\n  return s*f*(f-1.0)*((16.0*k-4.0)*f*(f-1.0)-1.0);\n}\nvec3 RotateAroundAxis( vec3 center, vec3 original, vec3 u, float angle )\n{\n  original -= center;\n  float C = cos( angle );\n  float S = sin( angle );\n  float t = 1.0 - C;\n  float m00 = t * u.x * u.x + C;\n  float m01 = t * u.x * u.y - S * u.z;\n  float m02 = t * u.x * u.z + S * u.y;\n  float m10 = t * u.x * u.y + S * u.z;\n  float m11 = t * u.y * u.y + C;\n  float m12 = t * u.y * u.z - S * u.x;\n  float m20 = t * u.x * u.z - S * u.y;\n  float m21 = t * u.y * u.z + S * u.x;\n  float m22 = t * u.z * u.z + C;\n  mat3 finalMatrix = mat3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );\n  return finalMatrix*original + center;\n}\nvec4 frag () {\n  float xoffset = windXPosition;\n  float noise = ( ( xoffset + ( cc_time.x * WindNoiseSpeed ) ) * WindNoiseScale );\n  float fastnoise = FastNoise101_g1(noise);\n  float intensity = mix( WindMinIntensity , WindMaxIntensity , ( fastnoise + 0.5 ));\n  float factor = clamp( ( ( windRotationWindFactor * intensity ) + windRotation ) , -windMaxRotation , windMaxRotation );\n  float winflipy = ( uv0.y + windFlip );\n  vec3 d1 = (vec3(0.5 , -windFlip , 0.0));\n  vec2 d2 = (vec2(0.0 , ( windSquishFactor * min( ( ( windSquishWindFactor * abs( intensity ) ) + abs( windRotation ) ) , windMaxRotation ) * winflipy )));\n  vec3 newuv = RotateAroundAxis( d1, vec3( ( d2 + uv0 ) ,  0.0 ), vec3( 0,0,1 ), ( factor * winflipy ) );\n  vec4 c = texture( cc_spriteTexture,newuv.xy ) * color;\n  c.rgb *= c.a;\n  ALPHA_TEST(c);\n  return c;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\n  precision highp float;\n  uniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\n  #if USE_LOCAL\n    uniform highp mat4 cc_matWorld;\n  #endif\n  #if SAMPLE_FROM_RT\n    #define QUATER_PI         0.78539816340\n    #define HALF_PI           1.57079632679\n    #define PI                3.14159265359\n    #define PI2               6.28318530718\n    #define PI4               12.5663706144\n    #define INV_QUATER_PI     1.27323954474\n    #define INV_HALF_PI       0.63661977237\n    #define INV_PI            0.31830988618\n    #define INV_PI2           0.15915494309\n    #define INV_PI4           0.07957747155\n    #define EPSILON           1e-6\n    #define EPSILON_LOWP      1e-4\n    #define LOG2              1.442695\n    #define EXP_VALUE         2.71828183f\n    #define FP_MAX            65504.0\n    #define FP_SCALE          0.0009765625\n    #define FP_SCALE_INV      1024.0\n    #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n  #endif\n  attribute vec3 a_position;\n  attribute vec2 a_texCoord;\n  attribute vec4 a_color;\n  varying vec4 color;\n  varying vec2 uv0;\n  vec4 vert () {\n    vec4 pos = vec4(a_position, 1);\n    #if USE_LOCAL\n      pos = cc_matWorld * pos;\n    #endif\n    #if USE_PIXEL_ALIGNMENT\n      pos = cc_matView * pos;\n      pos.xyz = floor(pos.xyz);\n      pos = cc_matProj * pos;\n    #else\n      pos = cc_matViewProj * pos;\n    #endif\n    uv0 = a_texCoord;\n#if SAMPLE_FROM_RT\n      uv0 = cc_cameraPos.w > 1.0 ? vec2(uv0.x, 1.0 - uv0.y) : uv0;\n#endif\n    color = a_color;\n    return pos;\n  }\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nuniform highp vec4 cc_time;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#if USE_ALPHA_TEST\n      uniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n    if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n    if (alpha < alphaThreshold) discard;\n  #endif\n}\nvarying vec4 color;\nvarying vec2 uv0;\nuniform sampler2D cc_spriteTexture;\n   uniform float windRotationWindFactor;\n   uniform float WindMinIntensity;\n   uniform float WindMaxIntensity;\n   uniform float windXPosition;\n   uniform float WindNoiseSpeed;\n   uniform float WindNoiseScale;\n   uniform float windRotation;\n   uniform float windMaxRotation;\n   uniform float windFlip;\n   uniform float windSquishFactor;\n   uniform float windSquishWindFactor;\nfloat FastNoise101_g1( float x )\n{\n  float i = floor(x);\n  float f = fract(x);\n  float s = sign(fract(x/2.0)-0.5);\n  float k = 0.5+0.5*sin(i);\n  return s*f*(f-1.0)*((16.0*k-4.0)*f*(f-1.0)-1.0);\n}\nvec3 RotateAroundAxis( vec3 center, vec3 original, vec3 u, float angle )\n{\n  original -= center;\n  float C = cos( angle );\n  float S = sin( angle );\n  float t = 1.0 - C;\n  float m00 = t * u.x * u.x + C;\n  float m01 = t * u.x * u.y - S * u.z;\n  float m02 = t * u.x * u.z + S * u.y;\n  float m10 = t * u.x * u.y + S * u.z;\n  float m11 = t * u.y * u.y + C;\n  float m12 = t * u.y * u.z - S * u.x;\n  float m20 = t * u.x * u.z - S * u.y;\n  float m21 = t * u.y * u.z + S * u.x;\n  float m22 = t * u.z * u.z + C;\n  mat3 finalMatrix = mat3( m00, m01, m02, m10, m11, m12, m20, m21, m22 );\n  return finalMatrix*original + center;\n}\nvec4 frag () {\n  float xoffset = windXPosition;\n  float noise = ( ( xoffset + ( cc_time.x * WindNoiseSpeed ) ) * WindNoiseScale );\n  float fastnoise = FastNoise101_g1(noise);\n  float intensity = mix( WindMinIntensity , WindMaxIntensity , ( fastnoise + 0.5 ));\n  float factor = clamp( ( ( windRotationWindFactor * intensity ) + windRotation ) , -windMaxRotation , windMaxRotation );\n  float winflipy = ( uv0.y + windFlip );\n  vec3 d1 = (vec3(0.5 , -windFlip , 0.0));\n  vec2 d2 = (vec2(0.0 , ( windSquishFactor * min( ( ( windSquishWindFactor * abs( intensity ) ) + abs( windRotation ) ) , windMaxRotation ) * winflipy )));\n  vec3 newuv = RotateAroundAxis( d1, vec3( ( d2 + uv0 ) ,  0.0 ), vec3( 0,0,1 ), ( factor * winflipy ) );\n  vec4 c = texture2D(cc_spriteTexture,newuv.xy ) * color;\n  c.rgb *= c.a;\n  ALPHA_TEST(c);\n  return c;\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["USE_LOCAL"]}],"samplerTextures":[{"name":"cc_spriteTexture","defines":[]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":49,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":51}},"defines":[{"name":"USE_LOCAL","type":"boolean","defines":[]},{"name":"SAMPLE_FROM_RT","type":"boolean","defines":[]},{"name":"USE_PIXEL_ALIGNMENT","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]}]}],[{"passes":[{"program":"../shader/Wind|s-vs:vert|s-fs:frag","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"rasterizerState":{"cullMode":0},"depthStencilState":{"depthTest":false,"depthWrite":false},"properties":{"windRotationWindFactor":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,2.5]}},"WindMinIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[-2,2]}},"WindMaxIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[-2,2]}},"windXPosition":{"type":13,"value":[0.5]},"WindNoiseSpeed":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,10]}},"WindNoiseScale":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]}},"windRotation":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[-3.14,3.14]}},"windMaxRotation":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[1,3.14]}},"windFlip":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[-1,1]}},"windSquishFactor":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,2.5]}},"windSquishWindFactor":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]}}}}]}]]],0,0,[],[],[]],[[[15,[{"shiftHueSpeed":9.07,"shiftHueFade":0.78,"timeScale":0.02}],[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}]]],0,0,[0],[3],[27]],[[[10,"../shader/Shift Hue",[{"hash":2298487755,"name":"../shader/Shift Hue|s-vs:vert|s-fs:frag","blocks":[{"name":"ALPHA_TEST_DATA","stageFlags":16,"binding":0,"members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"]},{"name":"RATE","stageFlags":16,"binding":1,"members":[{"name":"shiftHueSpeed","type":13,"count":1},{"name":"shiftHueFade","type":13,"count":1},{"name":"timeScale","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"shiftHueShaderMask","type":28,"count":1,"stageFlags":16,"binding":2,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":21,"location":1,"defines":[]},{"name":"a_color","format":44,"location":2,"defines":[]}],"varyings":[{"name":"color","type":16,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"uv0","type":14,"count":1,"stageFlags":17,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if USE_LOCAL\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n  };\n#endif\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec2 a_texCoord;\nlayout(location = 2) in vec4 a_color;\nlayout(location = 0) out vec4 color;\nlayout(location = 1) out vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matWorld * pos;\n  #endif\n  #if USE_PIXEL_ALIGNMENT\n    pos = cc_matView * pos;\n    pos.xyz = floor(pos.xyz);\n    pos = cc_matProj * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#if USE_ALPHA_TEST\n  layout(set = 1, binding = 0) uniform ALPHA_TEST_DATA {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n    if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n    if (alpha < alphaThreshold) discard;\n  #endif\n}\nlayout(location = 0) in vec4 color;\nlayout(location = 1) in vec2 uv0;\nlayout(set = 2, binding = 11) uniform sampler2D cc_spriteTexture;\nlayout(set = 1, binding = 2) uniform sampler2D shiftHueShaderMask;\nlayout(set = 1, binding = 1) uniform RATE{\n  float shiftHueSpeed;\n  float shiftHueFade;\n  float timeScale;\n};\nvec3 RGBToHSV(vec3 c)\n{\n  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n  vec4 p = mix( vec4( c.bg, K.wz ), vec4( c.gb, K.xy ), step( c.b, c.g ) );\n  vec4 q = mix( vec4( p.xyw, c.r ), vec4( c.r, p.yzx ), step( p.x, c.r ) );\n  float d = q.x - min( q.w, q.y );\n  float e = 1.0e-10;\n  return vec3( abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 HSVToRGB(vec3 c)\n{\n  vec4 K = vec4( 1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0 );\n  vec3 p = abs( fract( vec3(c.x) + K.xyz ) * 6.0 - vec3(K.w));\n  return c.z * mix( vec3(K.x), clamp(p - vec3(K.x), 0.0, 1.0), c.y );\n}\nvec4 frag () {\n  vec4 source = texture( cc_spriteTexture, uv0 );\n  vec3 hsv = RGBToHSV( source.rgb );\n  vec3 trgb = HSVToRGB( vec3(( ( (cc_time.x*timeScale) * shiftHueSpeed ) + hsv.x ),hsv.y,hsv.z) );\n  vec4 mask = texture( shiftHueShaderMask, uv0 );\n  vec3 outcolor = mix( source.rgb , trgb , ( shiftHueFade * ( mask.r * mask.a ) ));\n  vec4 c = vec4(outcolor , source.a)*color;\n  c.rgb *= c.a;\n  ALPHA_TEST(c);\n  return c;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if USE_LOCAL\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n  };\n#endif\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nout vec4 color;\nout vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matWorld * pos;\n  #endif\n  #if USE_PIXEL_ALIGNMENT\n    pos = cc_matView * pos;\n    pos.xyz = floor(pos.xyz);\n    pos = cc_matProj * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#if USE_ALPHA_TEST\n  layout(std140) uniform ALPHA_TEST_DATA {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n    if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n    if (alpha < alphaThreshold) discard;\n  #endif\n}\nin vec4 color;\nin vec2 uv0;\nuniform sampler2D cc_spriteTexture;\nuniform sampler2D shiftHueShaderMask;\nlayout(std140) uniform RATE{\n  float shiftHueSpeed;\n  float shiftHueFade;\n  float timeScale;\n};\nvec3 RGBToHSV(vec3 c)\n{\n  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n  vec4 p = mix( vec4( c.bg, K.wz ), vec4( c.gb, K.xy ), step( c.b, c.g ) );\n  vec4 q = mix( vec4( p.xyw, c.r ), vec4( c.r, p.yzx ), step( p.x, c.r ) );\n  float d = q.x - min( q.w, q.y );\n  float e = 1.0e-10;\n  return vec3( abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 HSVToRGB(vec3 c)\n{\n  vec4 K = vec4( 1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0 );\n  vec3 p = abs( fract( vec3(c.x) + K.xyz ) * 6.0 - vec3(K.w));\n  return c.z * mix( vec3(K.x), clamp(p - vec3(K.x), 0.0, 1.0), c.y );\n}\nvec4 frag () {\n  vec4 source = texture( cc_spriteTexture, uv0 );\n  vec3 hsv = RGBToHSV( source.rgb );\n  vec3 trgb = HSVToRGB( vec3(( ( (cc_time.x*timeScale) * shiftHueSpeed ) + hsv.x ),hsv.y,hsv.z) );\n  vec4 mask = texture( shiftHueShaderMask, uv0 );\n  vec3 outcolor = mix( source.rgb , trgb , ( shiftHueFade * ( mask.r * mask.a ) ));\n  vec4 c = vec4(outcolor , source.a)*color;\n  c.rgb *= c.a;\n  ALPHA_TEST(c);\n  return c;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp mat4 cc_matViewProj;\n#if USE_LOCAL\n  uniform highp mat4 cc_matWorld;\n#endif\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying vec4 color;\nvarying vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matWorld * pos;\n  #endif\n  #if USE_PIXEL_ALIGNMENT\n    pos = cc_matView * pos;\n    pos.xyz = floor(pos.xyz);\n    pos = cc_matProj * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nuniform highp vec4 cc_time;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#if USE_ALPHA_TEST\n      uniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n    if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n    if (alpha < alphaThreshold) discard;\n  #endif\n}\nvarying vec4 color;\nvarying vec2 uv0;\nuniform sampler2D cc_spriteTexture;\nuniform sampler2D shiftHueShaderMask;\n    uniform float shiftHueSpeed;\n    uniform float shiftHueFade;\n    uniform float timeScale;\nvec3 RGBToHSV(vec3 c)\n{\n  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n  vec4 p = mix( vec4( c.bg, K.wz ), vec4( c.gb, K.xy ), step( c.b, c.g ) );\n  vec4 q = mix( vec4( p.xyw, c.r ), vec4( c.r, p.yzx ), step( p.x, c.r ) );\n  float d = q.x - min( q.w, q.y );\n  float e = 1.0e-10;\n  return vec3( abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 HSVToRGB(vec3 c)\n{\n  vec4 K = vec4( 1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0 );\n  vec3 p = abs( fract( vec3(c.x) + K.xyz ) * 6.0 - vec3(K.w));\n  return c.z * mix( vec3(K.x), clamp(p - vec3(K.x), 0.0, 1.0), c.y );\n}\nvec4 frag () {\n  vec4 source = texture2D(cc_spriteTexture, uv0 );\n  vec3 hsv = RGBToHSV( source.rgb );\n  vec3 trgb = HSVToRGB( vec3(( ( (cc_time.x*timeScale) * shiftHueSpeed ) + hsv.x ),hsv.y,hsv.z) );\n  vec4 mask = texture2D(shiftHueShaderMask, uv0 );\n  vec3 outcolor = mix( source.rgb , trgb , ( shiftHueFade * ( mask.r * mask.a ) ));\n  vec4 c = vec4(outcolor , source.a)*color;\n  c.rgb *= c.a;\n  ALPHA_TEST(c);\n  return c;\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["USE_LOCAL"]}],"samplerTextures":[{"name":"cc_spriteTexture","defines":[]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":49,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":43}},"defines":[{"name":"USE_LOCAL","type":"boolean","defines":[]},{"name":"USE_PIXEL_ALIGNMENT","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]}]}],[{"passes":[{"program":"../shader/Shift Hue|s-vs:vert|s-fs:frag","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"rasterizerState":{"cullMode":0},"depthStencilState":{"depthTest":false,"depthWrite":false},"properties":{"shiftHueShaderMask":{"value":"grey","type":28},"shiftHueSpeed":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.01,"range":[0,10]}},"shiftHueFade":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.01,"range":[0,10]}},"timeScale":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.01,"range":[0,1]}}}}]}]]],0,0,[],[],[]],[[{"name":"7","rect":{"x":0,"y":0,"width":496,"height":260},"offset":{"x":0,"y":0},"originalSize":{"width":496,"height":260},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[1],[28]],[[{"name":"11","rect":{"x":0,"y":0,"width":80,"height":80},"offset":{"x":0,"y":0},"originalSize":{"width":80,"height":80},"rotated":false,"capInsets":[0,0,0,0],"packable":false}],[0],0,[0],[1],[29]],[[{"name":"12","rect":{"x":0,"y":0,"width":80,"height":80},"offset":{"x":0,"y":0},"originalSize":{"width":80,"height":80},"rotated":false,"capInsets":[0,0,0,0],"packable":false}],[0],0,[0],[1],[30]],[[{"name":"tanchuan06","rect":{"x":2,"y":2,"width":103,"height":126},"offset":{"x":0,"y":-0.5},"originalSize":{"width":107,"height":129},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[1],[31]],[[{"name":"4","rect":{"x":0,"y":0,"width":495,"height":259},"offset":{"x":-0.5,"y":0.5},"originalSize":{"width":496,"height":260},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[1],[32]],[[{"name":"6","rect":{"x":1,"y":1,"width":526,"height":274},"offset":{"x":0,"y":0},"originalSize":{"width":526,"height":274},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[1],[33]],[[[15,[{"addHueSaturation":0.71,"addHueSpeed":0,"timeScale":0,"addHueFade":0}],[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}]]],0,0,[0],[3],[34]],[[{"name":"16","rect":{"x":0,"y":0,"width":80,"height":80},"offset":{"x":0,"y":0},"originalSize":{"width":80,"height":80},"rotated":false,"capInsets":[0,0,0,0],"packable":false}],[0],0,[0],[1],[35]]]]
